#import "../common/assertions.jsligo" "Assertions"
#import "../common/errors.mligo" "Errors"
#import "../common/tzip12.datatypes.jsligo" "TZIP12"
#import "../common/tzip16.datatypes.jsligo" "TZIP16"

 export type ledger = big_map<[address, nat], nat>;
 export type operator = address;
 export type operators = big_map<[address, operator], set<nat>>;
 export type storage<T> = {
    ledger: ledger,
    operators: operators,
    token_metadata: TZIP12.tokenMetadata,
    metadata: TZIP16.metadata,
    extension: T
 };
 type ret<T> = [list<operation>, storage<T>];
 //operators

 export const assert_authorisation = (
    [operators, from_, token_id]: [operators, address, nat]
 ): unit => {
    const sender_ = (Tezos.get_sender());
    if (sender_ != from_) {
       const authorized =
          match((Big_map.find_opt([from_, sender_], operators))) {
             when (Some(a)):
                a
             when (None()):
                Set.empty
          };
       if (! (Set.mem(token_id, authorized))) {
          return failwith(Errors.not_operator)
       }
    }
 };
 export const add_operator = (
    [operators, owner, operator, token_id]: [
       operators,
       address,
       operator,
       nat
    ]
 ): operators => {
    if (owner == operator) {
       return operators
    } // assert_authorisation always allow the owner so this case is not relevant
     else {
       Assertions.assert_update_permission(owner);
       let auth_tokens =
          match(Big_map.find_opt([owner, operator], operators)) {
             when (Some(ts)):
                ts
             when (None()):
                Set.empty
          };
       auth_tokens = Set.add(token_id, auth_tokens);
       return Big_map.update([owner, operator], Some(auth_tokens), operators)
    }
 };
 export const remove_operator = (
    [operators, owner, operator, token_id]: [
       operators,
       address,
       operator,
       nat
    ]
 ): operators => {
    if (owner == operator) {
       return operators
    } // assert_authorisation always allow the owner so this case is not relevant
     else {
       Assertions.assert_update_permission(owner);
       const auth_tokens: option<set<nat>> =
          match(Big_map.find_opt([owner, operator], operators)) {
             when (Some(toks)):
                do {
                   const ts = Set.remove(token_id, toks);
                   if (Set.cardinal(ts) == 0n) {
                      return None()
                   } else {
                      return Some(ts)
                   }
                }
             when (None()):
                None()
          };
       return Big_map.update([owner, operator], auth_tokens, operators)
    }
 }
 // ledger

 export const get_for_user = (
    [ledger, owner, token_id]: [ledger, address, nat]
 ): nat =>
    match((Big_map.find_opt([owner, token_id], ledger))) {
       when (Some(a)):
          a
       when (None()):
          0 as nat
    };
 const set_for_user = (
    [ledger, owner, token_id, amount_]: [ledger, address, nat, nat]
 ): ledger =>
    Big_map.update([owner, token_id], Some(amount_), ledger);
 export const decrease_token_amount_for_user = (
    [ledger, from_, token_id, amount_]: [ledger, address, nat, nat]
 ): ledger => {
    let balance_ = get_for_user([ledger, from_, token_id]);
    assert_with_error((balance_ >= amount_), Errors.ins_balance);
    balance_ = abs(balance_ - amount_);
    return set_for_user([ledger, from_, token_id, balance_])
 };
 export const increase_token_amount_for_user = (
    [ledger, to_, token_id, amount_]: [ledger, address, nat, nat]
 ): ledger => {
    let balance_ = get_for_user([ledger, to_, token_id]);
    balance_ = balance_ + amount_;
    return set_for_user([ledger, to_, token_id, balance_])
 }
 // storage

 export const set_ledger = <T>([s, ledger]: [storage<T>, ledger]): storage<T> =>
    ({ ...s, ledger: ledger });
 export const get_operators = <T>(s: storage<T>): operators => s.operators;
 export const set_operators = <T>([s, operators]: [storage<T>, operators]): storage<T> =>
    ({ ...s, operators: operators })

 export const transfer = <T>(t: TZIP12.transfer, s: storage<T>): ret<T> => {
    const process_atomic_transfer = (from_: address) =>
       ([l, t]: [ledger, TZIP12.atomic_trans]): ledger => {
          const { to_, token_id, amount } = t;
          Assertions.assert_token_exist(s.token_metadata, token_id);
          assert_authorisation([s.operators, from_, token_id]);
          let ledger =
             decrease_token_amount_for_user([l, from_, token_id, amount]);
          ledger
          = increase_token_amount_for_user([ledger, to_, token_id, amount]);
          return ledger
       };
    const process_single_transfer = ([l, t]: [ledger, TZIP12.transfer_from]): ledger => {
       const { from_, txs } = t;
       const ledger = List.fold_left(process_atomic_transfer(from_), l, txs);
       return ledger
    };
    const ledger = List.fold_left(process_single_transfer, s.ledger, t);
    return [list([]), set_ledger([s, ledger])]
 };

 export const balance_of = <T>(b: TZIP12.balance_of, s: storage<T>): ret<T> => {
    const { requests, callback } = b;
    const get_balance_info = (request: TZIP12.request): TZIP12.callback => {
       const { owner, token_id } = request;
       Assertions.assert_token_exist(s.token_metadata, token_id);
       const balance_ = get_for_user([s.ledger, owner, token_id]);
       return ({ request: request, balance: balance_ })
    };
    const callback_param = List.map(get_balance_info, requests);
    const operation =
       Tezos.transaction(Main(callback_param), 0mutez, callback);
    return [list([operation]), s]
 };

 export const update_operators = <T>(updates: TZIP12.update_operators, s: storage<T>): ret<T> => {
    const update_operator = (
       [operators, update]: [operators, TZIP12.unit_update]
    ): operators =>
       match(update) {
          when (Add_operator(operator)):
             add_operator(
                [
                   operators,
                   operator.owner,
                   operator.operator,
                   operator.token_id
                ]
             )
          when (Remove_operator(operator)):
             remove_operator(
                [
                   operators,
                   operator.owner,
                   operator.operator,
                   operator.token_id
                ]
             )
       };
    let operators = get_operators(s);
    operators = List.fold_left(update_operator, operators, updates);
    const store = set_operators([s, operators]);
    return [list([]), store]
 };

 export const get_balance = <T>(p: [address, nat], s: storage<T>): nat => {
    const [owner, token_id] = p;
    Assertions.assert_token_exist(s.token_metadata, token_id);
    return match(Big_map.find_opt([owner, token_id], s.ledger)) {
       when (None()):
          0n
       when (Some(n)):
          n
    }
 };

 export const total_supply = <T>(_token_id: nat, _s: storage<T>): nat =>
    failwith(Errors.not_available);

 export const all_tokens = <T>(_: unit, _s: storage<T>): set<nat> =>
    failwith(Errors.not_available);

 export const is_operator = <T>(op: TZIP12.operator, s: storage<T>): bool => {
    const authorized =
       match(Big_map.find_opt([op.owner, op.operator], s.operators)) {
          when (Some(opSet)):
             opSet
          when (None()):
             Set.empty
       };
    return (Set.size(authorized) > 0n || op.owner == op.operator)
 };

 export const token_metadata = <T>(p: nat, s: storage<T>): TZIP12.tokenMetadataData => {
    return match(Big_map.find_opt(p, s.token_metadata)) {
       when (Some(data)):
          data
       when (None()):
          failwith(Errors.undefined_token)
    }
 };


