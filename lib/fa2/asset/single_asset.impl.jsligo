#import "../common/errors.mligo" "Errors"

#import "../common/tzip12.datatypes.jsligo" "TZIP12"

#import "../common/tzip12.interfaces.jsligo" "TZIP12Interface"

#import "../common/tzip16.datatypes.jsligo" "TZIP16"

export namespace SingleAsset implements TZIP12Interface.FA2{
   export type Ledger = big_map<address, nat>;
   type operator = address;
   export type Operators = big_map<address, set<operator>>;
   export type storage = {
      ledger: Ledger,
      operators: Operators,
      token_metadata: TZIP12.tokenMetadata,
      metadata: TZIP16.metadata
   };
   type ret = [list<operation>, storage];
   //export namespace Operators {
   /** if transfer policy is Owner_or_operator_transfer */

   export const assert_authorisation = (operators: Operators, from_: address): unit => {
      const sender_ = Tezos.get_sender();
      if (sender_ == from_) return unit else {
         const authorized =
            match(Big_map.find_opt(from_, operators)) {
               when (Some(a)):
                  a
               when (None()):
                  Set.empty
            };
         if (Set.mem(sender_, authorized)) return unit else failwith(
            Errors.not_operator
         )
      }
   };
   const assert_update_permission = (owner: address): unit => {
      return assert_with_error(
         owner == Tezos.get_sender(),
         "The sender can only manage operators for his own token"
      )
   };
   export const add_operator = (
      operators: Operators,
      owner: address,
      operator: operator
   ): Operators => {
      if (owner == operator) return operators else {
         const _ = assert_update_permission(owner);
         let auths =
            match(Big_map.find_opt(owner, operators)) {
               when (Some(os)):
                  os
               when (None()):
                  Set.empty
            };
         auths = Set.add(operator, auths);
         return Big_map.update(owner, Some(auths), operators)
      }
   };
   export const remove_operator = (
      operators: Operators,
      owner: address,
      operator: operator
   ): Operators => {
      if (owner == operator) return operators else {
         const _ = assert_update_permission(owner);
         const auths =
            match(Big_map.find_opt(owner, operators)) {
               when (None()):
                  None()
               when (Some(ops)):
                  do {
                     let os = Set.remove(operator, ops);
                     if (Set.size(os) == 0n) return None() else return Some(os)
                  }
            };
         return Big_map.update(owner, auths, operators)
      }
   }
   //export namespace Ledger {

   export const get_for_user = (ledger: Ledger, owner: address): nat =>
      match(Big_map.find_opt(owner, ledger)) {
         when (Some(tokens)):
            tokens
         when (None()):
            0 as nat
      };
   const update_for_user = (ledger: Ledger, owner: address, amount_: nat): Ledger =>
      Big_map.update(owner, Some(amount_), ledger);
   export const decrease_token_amount_for_user = (
      ledger: Ledger,
      from_: address,
      amount_: nat
   ): Ledger => {
      let tokens = get_for_user(ledger, from_);
      const _ = assert_with_error(tokens >= amount_, Errors.ins_balance);
      tokens = abs(tokens - amount_);
      return update_for_user(ledger, from_, tokens)
   };
   export const increase_token_amount_for_user = (
      ledger: Ledger,
      to_: address,
      amount_: nat
   ): Ledger => {
      let tokens = get_for_user(ledger, to_);
      tokens = tokens + amount_;
      return update_for_user(ledger, to_, tokens)
   }
   //};
   //export namespace Storage {

   export const get_amount_for_owner = (s: storage, owner: address) =>
      get_for_user(s.ledger, owner);
   export const set_ledger = (s: storage, ledger: Ledger) =>
      ({ ...s, ledger: ledger });
   export const get_operators = (s: storage) => s.operators;
   export const set_operators = (s: storage, operators: Operators) =>
      ({ ...s, operators: operators })
   /** transfert entrypoint*/

   @entry
   const transfer = (t: TZIP12.transfer, s: storage): [list<operation>, storage] => {
      /* This function process the "txs" list. Since all transfer share the same "from_" address, we use a se */

      const process_atomic_transfer = (from_: address) =>
         ([ledger, t]: [Ledger, TZIP12.atomic_trans]): Ledger => {
            const { to_, token_id, amount } = t;
            ignore(token_id);
            const _ = assert_authorisation(s.operators, from_);
            let l = decrease_token_amount_for_user(ledger, from_, amount);
            return increase_token_amount_for_user(l, to_, amount)
         };
      const process_single_transfer = (
         [ledger, t]: [Ledger, TZIP12.transfer_from]
      ): Ledger => {
         const { from_, txs } = t;
         return List.fold_left(process_atomic_transfer(from_), ledger, txs)
      };
      const ledger = List.fold_left(process_single_transfer, s.ledger, t);
      const store = set_ledger(s, ledger);
      return [list([]), store]
   };
   /** balance_of entrypoint
*/

   @entry
   const balance_of = (b: TZIP12.balance_of, s: storage): [
      list<operation>,
      storage
   ] => {
      const { requests, callback } = b;
      const get_balance_info = (request: TZIP12.request): TZIP12.callback => {
         const { owner, token_id } = request;
         ignore(token_id);
         const balance_ = get_amount_for_owner(s, owner);
         return { request: request, balance: balance_ }
      };
      const callback_param = List.map(get_balance_info, requests);
      const operation =
         Tezos.transaction(Main(callback_param), 0mutez, callback);
      return [list([operation]), s]
   };
   /**
Add or Remove token operators for the specified token owners and token IDs.


The entrypoint accepts a list of update_operator commands. If two different
commands in the list add and remove an operator for the same token owner and
token ID, the last command in the list MUST take effect.


It is possible to update operators for a token owner that does not hold any token
balances yet.


Operator relation is not transitive. If C is an operator of B and if B is an
operator of A, C cannot transfer tokens that are owned by A, on behalf of B.


*/

   @entry
   const update_operators = (updates: TZIP12.update_operators, s: storage): [
      list<operation>,
      storage
   ] => {
      const update_operator = (
         [operators, update]: [Operators, TZIP12.unit_update]
      ): Operators =>
         match(update) {
            when (Add_operator(operator)):
               add_operator(operators, operator.owner, operator.operator)
            when (Remove_operator(operator)):
               remove_operator(operators, operator.owner, operator.operator)
         };
      const operators =
         List.fold_left(update_operator, get_operators(s), updates);
      const store = set_operators(s, operators);
      return [list([]), store]
   };
   export const assert_token_exist = (s: storage, token_id: nat): unit => {
      const _ =
         Option.unopt_with_error(
            Big_map.find_opt(token_id, s.token_metadata),
            Errors.undefined_token
         )
   };
   @view
   const get_balance = (p: [address, nat], s: storage): nat => {
      const [owner, token_id] = p;
      assert_token_exist(s, token_id);
      return match(Big_map.find_opt(owner, s.ledger)) {
         when (None()):
            0n
         when (Some(n)):
            n
      }
   };
   @view
   const total_supply = (_token_id: nat, _s: storage): nat =>
      failwith(Errors.not_available);
   @view
   const all_tokens = (_: unit, _s: storage): set<nat> =>
      failwith(Errors.not_available);
   @view
   const is_operator = (op: TZIP12.operator, s: storage): bool => {
      const authorized =
         match(Big_map.find_opt(op.owner, s.operators)) {
            when (Some(opSet)):
               opSet
            when (None()):
               Set.empty
         };
      return (Set.mem(op.operator, authorized) || op.owner == op.operator)
   };
   @view
   const token_metadata = (p: nat, s: storage): TZIP12.tokenMetadataData => {
      return match(Big_map.find_opt(p, s.token_metadata)) {
         when (Some(data)):
            data
         when (None()):
            failwith(Errors.undefined_token)
      }
   };
};
