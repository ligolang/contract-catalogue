#import "nft.impl.datatypes.jsligo" "Datatypes"

#import "../common/assertions.jsligo" "Assertions"
#import "../common/errors.mligo" "Errors"
#import "../common/tzip12.datatypes.jsligo" "TZIP12"
#import "../common/tzip12.interfaces.jsligo" "TZIP12Interface"
#import "../common/tzip16.datatypes.jsligo" "TZIP16"

  export const assert_authorisation = (
    operators: Datatypes.operators,
    from_: address,
    token_id: nat
  ): unit => {
    const sender_ = (Tezos.get_sender());
    if (sender_ != from_) {
      const authorized =
        match((Big_map.find_opt([from_, sender_], operators))) {
          when (Some(a)):
            a
          when (None()):
            Set.empty
        };
      if (! (Set.mem(token_id, authorized))) {
        return failwith(Errors.not_operator)
      }
    } else {
      return unit
    }
  };
  export const add_operator = (
    operators: Datatypes.operators,
    owner: address,
    operator: address,
    token_id: nat
  ): Datatypes.operators => {
    if (owner == operator) {
      return operators
    // assert_authorisation always allow the owner so this case is not relevant

    } else {
      Assertions.assert_update_permission(owner);
      let auth_tokens =
        match(Big_map.find_opt([owner, operator], operators)) {
          when (Some(ts)):
            ts
          when (None()):
            Set.empty
        };
      auth_tokens = Set.add(token_id, auth_tokens);
      return Big_map.update([owner, operator], Some(auth_tokens), operators)
    }
  };
  export const remove_operator = (
    operators: Datatypes.operators,
    owner: address,
    operator: address,
    token_id: nat
  ): Datatypes.operators => {
    if (owner == operator) {
      return operators
    // assert_authorisation always allow the owner so this case is not relevant

    } else {
      Assertions.assert_update_permission(owner);
      const auth_tokens: option<set<nat>> =
        match(Big_map.find_opt([owner, operator], operators)) {
          when (Some(ts)):
            do {
              const toks = Set.remove(token_id, ts);
              if (Set.cardinal(toks) == 0n) {
                return None()
              } else {
                return Some(toks)
              }
            }
          when (None()):
            None()
        };
      return Big_map.update([owner, operator], auth_tokens, operators)
    }
  }
  //  ledger 

  export const is_owner_of = (
    ledger: Datatypes.ledger,
    token_id: nat,
    owner: address
  ): bool => {
    const current_owner = Option.unopt(Big_map.find_opt(token_id, ledger));
    return (current_owner == owner)
  };
  const assert_owner_of = (
    ledger: Datatypes.ledger,
    token_id: nat,
    owner: address
  ): unit =>
    assert_with_error(is_owner_of(ledger, token_id, owner), Errors.ins_balance);
  export const transfer_token_from_user_to_user = (
    ledger: Datatypes.ledger,
    token_id: nat,
    from_: address,
    to_: address
  ): Datatypes.ledger => {
    assert_owner_of(ledger, token_id, from_);
    return Big_map.update(token_id, Some(to_), ledger)
  }
  export const set_ledger = (s: Datatypes.storage, ledger: Datatypes.ledger): Datatypes.
  storage =>
    ({ ...s, ledger: ledger });
  export const get_operators = (s: Datatypes.storage): Datatypes.operators =>
    s.operators;
  export const set_operators = (
    s: Datatypes.storage,
    operators: Datatypes.operators
  ): Datatypes.storage =>
    ({ ...s, operators: operators });
  @view
  const get_balance = (p: [address, nat], s: Datatypes.storage): nat => {
    const [owner, token_id] = p;
    Assertions.assert_token_exist(s.token_metadata, token_id);
    if (is_owner_of(s.ledger, token_id, owner)) {
      return 1n
    } else {
      return 0n
    }
  };
  @view
  const total_supply = (token_id: nat, s: Datatypes.storage): nat => {
    Assertions.assert_token_exist(s.token_metadata, token_id);
    return 1n
  };
  @view
  const all_tokens = (_: unit, _s: Datatypes.storage): set<nat> =>
    failwith(Errors.not_available);
  @view
  const is_operator = (_op: address, _s: Datatypes.storage): bool => {
    //TODO

    return true
  };
  @view
  const token_metadata = (p: nat, s: Datatypes.storage): TZIP12.
  tokenMetadataData => {
    return match(Big_map.find_opt(p, s.token_metadata)) {
      when (Some(data)):
        data
      when (None()):
        failwith(Errors.undefined_token)
    }
  }

