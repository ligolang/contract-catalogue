#import "tzip26.datatypes.jsligo" "TZIP26Datatypes"

export interface FA2_1 {
    // entry points

    /**
    The core behavior is the same as for FA2 with additional rules regarding allowances:

    To avoid conflicts between approve and update_operators, the operator's rights take precedence over those of the spender.
    If the allowance of the sender falls under zero, the transfer MUST fail  with the "FA2.1_INSUFFICIENT_ALLOWANCE" error message.
    By default, transfer of zero amount is allowed but beware of the behavior regarding allowance equals to 0 (or not set at all).

    In the case of a self-transfer (%from_ == %to_), make sure to not allow one to transfer more than they own, i.e. do not update %to_'s balance before %from_'s balance or check %from_'s balance is enough to transfer %amount.
    Associated events: transfer_event, balance_update, allowance_update
    **/
    @entry
    const transfer: (batch: TZIP26Datatypes.transfer, storage: storage) => ret;

    /**
    This entrypoint allows to increase or decrease the allowance set to %spender regarding a token %owner and a %token_id. The %spender can withdraw multiple times from the %owner's balance up to the set value.
    In case of a decrease below 0, no error is thrown, the allowance MUST be removed or set to 0. Beware of the case where anyone can transfer a 0 amount of tokens from anyone else because the default allowance is 0.
    Each call of transfer and export_ticket entrypoints decreases the allowance amount by the transferred amount of tokens, unless the transfer is called with %from_ being equal to sender or with %from_ being an operator on behalf of the sender.
    The standard does not specify who is permitted to approve on behalf of the token owner. Depending on the business use case, the particular implementation of the FA2.1 contract MAY limit allowance updates to a token owner (owner == SENDER) or it can be limited to an administrator.
    Associated events: allowance_update
    **/
    @entry
    const approve : (batch: TZIP26Datatypes.approve, storage: storage) => ret;

    /**
    The ticket id MUST be a pair containing the %token_id and any additional information (for example: a timestamp, ...) as an option bytes. The ticket value MUST be the %amount.
    The entrypoint MUST comply with the same policy as the transfer entrypoint. The balance of %from_ MUST be decreased by %amount for each associated %token_id. The balance of %to_ and %destination MUST remain unchanged. The total supply MUST remain unchanged.
    In the case of the option %destination being:


    None, an operation is emitted for each exported ticket to its corresponding address %to_ and this address MUST be typed as a (contract (ticket (pair nat (option bytes))). This allows tz addresses to receive tickets directly. The contract MUST fail with the error mnemonic "FA2.1_INVALID_DESTINATION" if an address %to_ can't be correctly typed.

    (Some contract), only one operation is necessary to transfer the tickets to this contract. The contract parameter (list (pair address (list (ticket (pair nat (option bytes)))))) MUST be constructed using (address %to_) and (list %tickets_to_export).
    **/
    @entry
    const export_ticket : (batch: TZIP26Datatypes.export_tickets, storage : storage) => ret;
    
    /**
    The ticket id MUST be a pair containing the %token_id and any additional information (for example: a timestamp, ...) as an option bytes. The ticket value MUST be the %amount.
    The entrypoint MUST comply with the same policy as the transfer entrypoint. The balance of %from_ MUST be decreased by %amount for each associated %token_id. The total supply MUST remain unchanged.
    Users must use the %action lambda to send exported tickets to the desired destination (tz addresses, smart contract entrypoints no matter the arguments, ...).
    âš  The lambda MUST NOT be executed by the FA2.1 contract itself but transferred to a sandbox contract instead whose sole purpose is to execute the lambda1. This avoids any security breach that could be caused by the operations resulting from the application of the lambda. Finally, the amount of tez transferred to this entrypoint should be forwarded to the sandbox as operations generated by the lambda may use it.
    Associated events: balance_update, allowance_update
    **/
    @entry
    const lambda_export : (batch : TZIP26Datatypes.lambda_export, storage : storage) => ret;

    /**
    The nat value of the ticket id of type (pair nat (option bytes)) represents the token_id and the ticket value represents the amount to be credited to the to_ address for the corresponding token_id. The ticket SHOULD be destroyed upon import but some use cases may need to store or send them elsewhere.
    If the ticket has not been created by the contract in which it is imported (ticketer != SELF_ADDRESS), the entrypoint SHOULD fail but some use cases may accept to import tickets minted by other contracts. In case of failure, the error mnemonic MUST be "FA2.1_INVALID_TICKET".
    The total supply SHOULD remain unchanged but some use cases may accept tickets from other contracts, for example, and therefore require an increase in the total supply.
    Associated events: balance_update, total_supply_update
    **/
    @entry
    const import_ticket: (batch: TZIP26Datatypes.import_tickets, storage : storage) => ret;



    // views
    
    /**
    Returns the number of tokens %token_id held for each %owner in the %requests list.
    If %owner isn't known by the contract or %token_id doesn't exist, the default returned value SHOULD be 0.
    **/
    @view
    const get_balance: (p: [address, nat], storage: storage) => nat;

    /**
    Returns the total supply of token_id. The total supply accounts for the number of tokens stored by the contract and the ones exported in tickets. i.e., exporting tickets MUST not change the total supply.
    If %token_id doesn't exist, the default returned value SHOULD be 0.
    **/
    @view
    const get_total_supply: (token_id: nat, storage: storage) => nat;
    
    /**
    Returns true if %operator is an operator of %owner for the token %token_id.
    If %owner or %operator isn't known by the contract or %token_id doesn't exist, the default returned value SHOULD be False.
    **/
    @view
    const is_operator: (op: TZIP26Datatypes.operator, storage: storage) => bool;
    
    /**  Returns the number of tokens %token_id allowed by %owner for %spender.
    If %owner or %spender isn't known by the contract or %token_id doesn't exist, the default returned value SHOULD be 0.
    **/
    @view
    const get_allowance: (p: TZIP26Datatypes.get_allowance, storage: storage) => nat /*allowance*/;

    /**     Returns the metadata associated to %token_id.
    If %token_id doesn't exist, the default returned value SHOULD be an empty map %token_info.
    **/

    @view
    const get_token_metadata: (p: nat, storage: storage) => TZIP26Datatypes.tokenMetadataData;

    /**
    Returns True if %token_id exists and False otherwise.
    **/
    @view
    const is_token: (token_id: nat, storage: storage) => bool /* token_exist */;
}

export interface FA2_1ImplementationDetails {
    // events

    /**
    MUST be triggered when a transfer occurs by any mechanism (a call to transfer but also custom entrypoints implementing a concept of transfer).
    In particular for the transfer entrypoint, each element of the list MUST trigger an event.
    The entrypoint export_ticket and import_ticket SHOULD NOT trigger this event.
    Associated entrypoints: transfer
    **/
    const transfer_event: (from_: address, to_: address, token_id: nat, amount: nat) => operation;

    /**
    MUST be triggered when the balance of a token owner is modified by any mechanism.
    Only one balance_update event is allowed per pair (%owner, %token_id) per transaction.
    int %diff represents the difference between nat %new_balance and the previous value (new_balance = old_balance + diff).
    Associated entrypoints: transfer, export_ticket, lambda_export, import_ticket
    **/
    const balance_update: (owner: address, token_id: nat, new_balance: nat, diff: int) => operation;

    /**
    MUST be triggered when the total supply of a %token_id is modified by any mechanism.
    int %diff represents the difference between nat %new_total_supply and the previous value (new_total_supply = old_total_supply + diff). So a positive %diff is a mint and a negative %diff is a burn.
    Only one total_supply_update event is allowed per %token_id per transaction.
    Associated entrypoints: import_ticket, mint (non standard)
    **/
    const total_supply_update: (token_id: nat, new_total_supply: nat, diff: int) => operation;

    /**
    MUST be triggered when an operator is updated by any mechanism.
    Only one operator_update event is allowed per triplet (%owner, %operator, %token_id) per transaction.
    %is_operator is true if %operator has been set as an operator of owner and false otherwise.
    Associated entrypoints: update_operators
    **/
    const operator_update: (owner: address, operator: address, token_id: nat, is_operator: bool) => operation;

    /**
    MUST be triggered when a spender's allowance is updated by any mechanism (including when the allowance is consumed by a call to transfer).
    int %diff represents the difference between nat %new_allowance and the previous value (new_allowance = old_allowance + diff).
    Only one allowance_update event is allowed per triplet (%owner, %spender, %token_id) per transaction.
    Associated entrypoints: approve, transfer, export_ticket, lambda_export
    **/
    const allowance_update: (owner: address, spender: address, token_id: nat, new_allowance: nat, diff: int) => operation;

    /**
    MUST be triggered when a token metadata is updated by any mechanism, for example mint, burn, reveal, etc.
    In case of the token is burned the option %new_metadata (map string bytes) MUST be none.
    Only one token_metadata_update event is allowed per %token_id per transaction.
    Associated entrypoints: mint (non standard)
    **/
    const token_metadata_update: (token_id: nat, new_metadata: map<string, bytes>) => operation;



    // Errors

    /** A ticket import failed because one of the tickets doesn't belong to the contract (ticketer != SELF_ADDRESS)
    **/
    const error_FA2_1_INVALID_TICKET : string; // = "FA2.1_INVALID_TICKET";
    
    /** A %destination address or contract can't be correctly typed to receive the exported tickets
    **/
    const error_FA2_1_INVALID_DESTINATION : string; // = "FA2.1_INVALID_DESTINATION";

    /** Ticket export/import isn't supported
    **/
    const error_FA2_1_TICKETS_UNSUPPORTED : string; // = "FA2.1_TICKETS_UNSUPPORTED";

    /** A token spender does not have sufficient allowance to transfer tokens from the owner's account
    **/
    const error_FA2_1_INSUFFICIENT_ALLOWANCE : string; // = "FA2.1_INSUFFICIENT_ALLOWANCE";

    /// Token metadata as an extension of TZIP-21
    /** One of the following "fungible", "semi-fungible" or "non-fungible".
    **/

    type tokenMetadata = {
      tokenKind: string;
    }
}